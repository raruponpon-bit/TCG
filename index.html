<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>デュエマ風カード対戦（PeerJS）</title>
<style>
  :root{--bg:#07102a;--panel:#0f1630;--muted:#9fb;--accent:#6aa0ff;}
  body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP";background:var(--bg);color:#eaf0ff;margin:0;padding:18px;}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;}
  .container{max-width:1100px;margin:14px auto;}
  .top{display:flex;gap:12px;align-items:center;margin:10px 0;}
  .box{background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,.5);}
  input, button, select{font-size:14px}
  button{background:#1b2a6b;border:none;padding:8px 10px;border-radius:8px;color:#fff;cursor:pointer}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px;}
  .small{font-size:13px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .zones{display:flex;gap:12px;margin-top:12px}
  .zone{flex:1;background:linear-gradient(180deg,#0b1225,#0f1630);padding:10px;border-radius:8px;min-height:120px}
  .cards{display:flex;gap:6px;flex-wrap:wrap}
  .card{padding:8px;border-radius:6px;background:#eaf0ff;color:#07102a;font-weight:700;min-width:90px;text-align:center;cursor:pointer}
  .card.small{padding:6px;font-size:13px;min-width:72px}
  #log{height:220px;overflow:auto;background:#06102a;padding:8px;border-radius:8px;color:#bfe}
  .status{font-weight:700;color:#bfe}
  footer{margin-top:16px;color:var(--muted);font-size:12px}
  .battle-line{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px}
  .hp{background:#0b1130;padding:6px 8px;border-radius:6px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .ability{font-size:12px;color:#623}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>デュエマ風カード対戦（inspired）</h1>
      <div class="small">PeerJS 接続で P2P 対戦 — GitHub Pages に置いて遊べます</div>
    </header>

    <div class="top">
      <div class="box" style="flex:1">
        <div class="row">
          <div style="flex:1">
            <div class="small">あなたのID</div>
            <div id="myId" class="status">取得中...</div>
          </div>
          <div style="width:320px">
            <div class="small">接続: 相手のIDを入力して「接続」</div>
            <div class="row">
              <input id="peerInput" placeholder="相手のIDを入力" style="flex:1;padding:8px;border-radius:8px;background:#06102a;border:1px solid #233;color:#cfe"/>
              <button id="connectBtn">接続</button>
            </div>
            <div style="margin-top:8px" class="row">
              <button id="startBtn">ゲーム開始</button>
              <button id="resetBtn">ローカルリセット</button>
            </div>
          </div>
        </div>

        <hr style="border-color:rgba(255,255,255,.03)"/>

        <div class="row" style="gap:12px;">
          <div style="flex:1">
            <div class="small">あなた</div>
            <div class="row" style="margin-top:6px;">
              <div class="hp">シールド <span id="myShieldCount">0</span></div>
              <div class="hp">デッキ <span id="myDeckCount">0</span></div>
              <div class="hp">マナ <span id="myManaCount">0</span></div>
              <div class="hp">バトル <span id="myBattleCount">0</span></div>
            </div>
            <div class="small">手札</div>
            <div id="myHand" class="cards" style="margin-top:6px"></div>
            <div class="small" style="margin-top:8px">マナゾーン（ここからマナに置く）</div>
            <div id="myManaZone" class="cards" style="margin-top:6px"></div>
          </div>

          <div style="flex:1">
            <div class="small">相手</div>
            <div class="row" style="margin-top:6px;">
              <div class="hp">シールド <span id="opShieldCount">0</span></div>
              <div class="hp">デッキ <span id="opDeckCount">0</span></div>
              <div class="hp">マナ <span id="opManaCount">0</span></div>
              <div class="hp">バトル <span id="opBattleCount">0</span></div>
            </div>
            <div class="small">相手の公開情報（シールドは枚数のみ）</div>
            <div id="opVisible" class="cards" style="margin-top:6px"></div>
          </div>
        </div>

        <div style="margin-top:10px" class="controls">
          <button id="placeManaBtn">マナに置く</button>
          <button id="endMainBtn">メイン終了（バトルへ）</button>
          <button id="endTurnBtn">ターン終了</button>
          <button id="autoDrawBtn">ドロー（デバッグ）</button>
        </div>

      </div>

      <div class="box" style="width:360px">
        <div class="small">接続ログ / ゲームログ</div>
        <div id="log"></div>
        <div style="margin-top:8px" class="small">接続状態: <span id="connState" class="status">未接続</span></div>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="box">
        <div class="small">バトルフィールド（相手と向かい合う）</div>
        <div style="display:flex;gap:12px;align-items:flex-end;justify-content:space-between;margin-top:12px">
          <div style="width:48%;background:linear-gradient(180deg,#07102a,#0a1530);padding:10px;border-radius:8px">
            <div class="small">あなたのバトルゾーン</div>
            <div id="myBattle" class="cards" style="margin-top:8px"></div>
          </div>
          <div style="width:48%;background:linear-gradient(180deg,#07102a,#0a1530);padding:10px;border-radius:8px">
            <div class="small">相手のバトルゾーン</div>
            <div id="opBattle" class="cards" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

      <div class="box">
        <div class="small">カードライブラリ（サンプル）</div>
        <div style="margin-top:8px">
          <div class="small">カードは JavaScript 内に定義。自由に追加・変更できます。</div>
          <div style="margin-top:8px" class="small">代表カード:</div>
          <div style="margin-top:8px" class="cards">
            <div class="card small">クリーチャー: 速攻 (cost1, p3000)</div>
            <div class="card small">クリーチャー: ブロッカー (cost2, p2000)</div>
            <div class="card small">呪文: ドロー2 (cost1)</div>
            <div class="card small">呪文: 破壊 (cost3)</div>
          </div>
        </div>

        <hr style="border-color:rgba(255,255,255,.03)"/>

        <div class="small">操作の流れ（簡潔）</div>
        <ol class="small">
          <li>Start -> 初期配置（シールド5、手札5、デッキ）</li>
          <li>ターン開始: ドロー -> マナに置く（任意1枚） -> 召喚/呪文 -> バトル -> ターン終了</li>
          <li>相手のシールドを0にしてからの直接トドメで勝利</li>
        </ol>
      </div>
    </div>

    <footer>注意: ルールは簡易化しています。カード追加や細かいテキスト効果は自由に拡張できます。</footer>
  </div>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/*
  デュエマ風ゲーム（PeerJS P2P）
  - 行動（action）を送って双方で処理を行うシステム
  - 状態は双方で同じ処理を行えば一致することを前提（イベントソーシャル）
  - エラーハンドリングは最低限。実用化時は追加を推奨。
*/

// -------------------- Card definitions --------------------
/*
  Card schema:
    { id, name, type: 'creature'|'spell', cost:int, power:int?, abilities:[], text:string }
  abilities example: 'haste', 'blocker', 'shieldTrigger-draw2', ...
*/
let CARD_POOL = [
  { id:'c1', name:'スピード・ビート', type:'creature', cost:1, power:3000, abilities:['haste'], text:'速攻' },
  { id:'c2', name:'ガードルーパー', type:'creature', cost:2, power:2000, abilities:['blocker'], text:'ブロッカー' },
  { id:'c3', name:'アタックゴーレム', type:'creature', cost:3, power:5000, abilities:[], text:'' },
  { id:'s1', name:'ドロー2', type:'spell', cost:1, power:0, abilities:[], text:'2枚ドロー' },
  { id:'s2', name:'クリーチャー破壊', type:'spell', cost:3, power:0, abilities:[], text:'相手クリーチャー1体破壊' },
  { id:'c4', name:'ビッグ・ブレイカー', type:'creature', cost:4, power:8000, abilities:[], text:'' },
  { id:'c5', name:'ライト・ディフェンダー', type:'creature', cost:2, power:1000, abilities:['blocker'], text:'ブロッカー' },
  { id:'s3', name:'パワー補強', type:'spell', cost:2, power:0, abilities:[], text:'自分のクリーチャー1体に+2000を与える(終了時解除)' }
];

// helper to clone card instance with unique UID
let uidCounter = 1;
function cloneCard(baseId){
  const b = CARD_POOL.find(c=>c.id===baseId);
  if(!b) return null;
  const copy = JSON.parse(JSON.stringify(b));
  copy.uid = `${b.id}-${uidCounter++}`;
  // runtime properties
  copy.tapped = false;
  copy.summonedThisTurn = false; // to implement summoning sickness
  return copy;
}

// -------------------- Game state --------------------
let state = {
  players: {
    A: { id:null, deck:[], hand:[], mana:[], battle:[], shield:[], grave:[] },
    B: { id:null, deck:[], hand:[], mana:[], battle:[], shield:[], grave:[] }
  },
  turn: null, // 'A' or 'B'
  phase: 'idle', // 'idle','draw','main','battle','end'
  started: false,
  localRole: null // 'A' or 'B' on each client
};

// -------------------- PeerJS P2P --------------------
let peer = new Peer();
let conn = null;
let remoteId = null;

const myIdEl = document.getElementById('myId');
const connStateEl = document.getElementById('connState');
const peerInput = document.getElementById('peerInput');
const connectBtn = document.getElementById('connectBtn');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');

const logEl = document.getElementById('log');

function log(msg){
  logEl.innerHTML = `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>` + logEl.innerHTML;
}

peer.on('open', id => {
  myIdEl.textContent = id;
  log('Peer ready: ' + id);
});

peer.on('connection', c => {
  if(conn){
    c.close(); // accept only one
    return;
  }
  conn = c;
  setupConnection();
});

connectBtn.onclick = () => {
  const id = peerInput.value.trim();
  if(!id) return alert('相手のIDを入力してください');
  conn = peer.connect(id);
  remoteId = id;
  setupConnection();
};

function setupConnection(){
  if(!conn) return;
  conn.on('open', () => {
    connStateEl.textContent = '接続済み';
    log('Connected to ' + conn.peer);
    // announce
    send({ type:'meta', msg:`hello from ${peer.id}` });
  });
  conn.on('data', data => {
    handleMessage(data);
  });
  conn.on('close', () => {
    connStateEl.textContent = '切断';
    log('Connection closed');
  });
}

function send(obj){
  if(conn && conn.open){
    conn.send(obj);
  }
}

// -------------------- Utility --------------------
function other(p){ return p==='A' ? 'B' : 'A'; }
function myRole(){ return state.localRole; }
function mySide(){ return state.players[state.localRole]; }
function opSide(){ return state.players[other(state.localRole)]; }

// -------------------- Deck / setup --------------------
function buildRandomDeck(){
  // build 20-card deck by sampling pool
  let d = [];
  for(let i=0;i<20;i++){
    const base = CARD_POOL[ Math.floor(Math.random()*CARD_POOL.length) ];
    d.push(cloneCard(base.id));
  }
  // shuffle
  for(let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}

function startGameAs(role){
  state.localRole = role;
  // initialize both players locally to same deterministic layout? We'll generate decks independently but to avoid mismatch we want both sides to generate same initial decks.
  // To keep both sides consistent, the starter (A) will generate both decks and send initial state to B.
  if(role === 'A'){
    // A generates both decks and initial zones
    state.players.A.deck = buildRandomDeck();
    state.players.B.deck = buildRandomDeck();
    // shields: top 5 to shield zone (face-down)
    for(let i=0;i<5;i++){
      state.players.A.shield.push(state.players.A.deck.pop());
      state.players.B.shield.push(state.players.B.deck.pop());
    }
    // initial hand: draw 5
    for(let i=0;i<5;i++){
      state.players.A.hand.push(state.players.A.deck.pop());
      state.players.B.hand.push(state.players.B.deck.pop());
    }
    state.turn = 'A';
    state.phase = 'draw';
    state.started = true;
    // broadcast full setup to B
    send({ type:'full-state', state:serializeStateForSend(state) });
    log('ゲーム開始: 初期状態を生成して送信しました');
  } else {
    // B requests initial state: but simpler — B waits for A to send full-state.
    log('参加者: ホストから初期状態を待っています');
  }
  renderAll();
}

function serializeStateForSend(s){
  // We must avoid sending functions; just send the whole object (cards include uid etc).
  return JSON.parse(JSON.stringify(s));
}

function applyReceivedFullState(s){
  state = s;
  state.localRole = (peer.id === conn.peer) ? 'A' : 'B'; // not reliable; instead sender included role? To keep simple: A sends full state; B sets localRole='B'
  // We'll assume that when B receives full-state, its localRole should be 'B' (we also set it below)
  renderAll();
}

// -------------------- Action system --------------------
/*
 Actions:
  - new-game (only A)
  - draw (player)
  - place-mana (player, cardUid)
  - play-card (player, cardUid) // summon or cast; payload: target?
  - attack (attackerUid, target: 'player' or targetUid)
  - declare-block (blockerUid, targetAttackerUid)
  - end-turn (player)
  - sync-state (full state backup) - used sparingly
*/
function handleMessage(msg){
  if(typeof msg !== 'object') return;
  if(msg.type === 'meta'){
    log('meta: ' + msg.msg);
  } else if(msg.type === 'full-state'){
    // B receives initial
    log('初期状態受信');
    state = msg.state;
    // set roles: sender is A, receiver is B
    if(conn && conn.peer){
      // if our id equals sender? can't know; instead we assume the one who sent is A
      state.localRole = (peer.id === Object.keys(state.players.A)[0]) ? 'A' : 'B'; // unreliable, so set localRole='B' for receiver
    }
    // safer: when A sent full-state it included role mapping; let's see: in startGameAs we didn't include mapping.
    // For reliability, we'll set localRole = (state.turn === 'A' && peer.id !== conn.peer) ? 'B' : state.localRole
    // Simpler: set localRole='B' (receiver)
    state.localRole = 'B';
    renderAll();
  } else if(msg.type === 'action'){
    const action = msg.action;
    log('相手 action: ' + JSON.stringify(action));
    applyAction(action, false);
  } else if(msg.type === 'sync'){
    // full sync from remote
    state = msg.state;
    renderAll();
  }
}

// applyAction: local indicates whether to broadcast
function applyAction(action, local=true){
  // Validate turn and permission lightly
  switch(action.act){
    case 'draw':
      if(state.turn !== action.player) { log('draw: ターン不一致'); return; }
      const pl = state.players[action.player];
      if(pl.deck.length) pl.hand.push(pl.deck.pop());
      log(`${action.player} がドロー`);
      break;

    case 'place-mana':
      {
        const pl = state.players[action.player];
        const idx = pl.hand.findIndex(c=>c.uid===action.uid);
        if(idx===-1){ log('place-mana: カードが手札にありません'); return; }
        const card = pl.hand.splice(idx,1)[0];
        pl.mana.push(card);
        log(`${action.player} がマナに置いた: ${card.name}`);
      }
      break;

    case 'play-card':
      {
        // play: if creature -> summon to battle zone (cost check)
        const pl = state.players[action.player];
        const cost = action.cost;
        // check mana
        if(pl.mana.length < cost){ log('play-card: マナ不足'); return; }
        // find in hand
        const idx = pl.hand.findIndex(c=>c.uid===action.uid);
        if(idx===-1){ log('play-card: カードが手札にありません'); return; }
        const card = pl.hand.splice(idx,1)[0];
        // pay mana: remove first cost mana (simple)
        for(let i=0;i<cost;i++) pl.mana.pop(); // simplified mana payment
        if(card.type === 'creature'){
          card.tapped = false;
          card.summonedThisTurn = true;
          pl.battle.push(card);
          log(`${action.player} が召喚: ${card.name} (p:${card.power})`);
        } else if(card.type === 'spell'){
          // resolve simple spell effects immediately
          resolveSpell(action.player, card, action);
          pl.grave.push(card);
          log(`${action.player} が呪文を使用: ${card.name}`);
        }
      }
      break;

    case 'attack':
      {
        // attackerUid attacks target: either 'player' or a creature uid
        const p = action.player;
        if(state.turn !== p){ log('attack: 今はあなたのターンではない'); return; }
        const attackerOwner = state.players[p];
        const attacker = findAndRemoveFromBattle(attackerOwner, action.attackerUid, false); // don't remove; will reference
        if(!attacker){ log('attack: アタッカーが見つかりません'); return; }
        // ensure attacker not tapped and not summoning-sick unless haste
        if(attacker.tapped){ log('attack: アタッカーは既にタップされています'); return; }
        if(attacker.summonedThisTurn && !attacker.abilities.includes('haste')){ log('attack: 召喚したてのクリーチャーは攻撃不可'); return; }

        // mark tapped
        attacker.tapped = true;

        // defender side
        const defender = state.players[ other(p) ];
        // check for blockers: if defender has blocker creatures, they may choose to block.
        const blockers = defender.battle.filter(c=>c.abilities && c.abilities.includes('blocker') && !c.tapped);
        if(action.target === 'player'){
          if(blockers.length > 0 && action.declaredBlockUid){
            // block assigned by defender (should be sent in action by remote)
            const blockUid = action.declaredBlockUid;
            const blockCard = defender.battle.find(c=>c.uid===blockUid);
            if(blockCard){
              // resolve fight between attacker and blocker
              log(`ブロッカー ${blockCard.name} が ${attacker.name} をブロック`);
              resolveCombat(attacker, blockCard, p, other(p));
              // check deaths moved to grave
              cleanupDead();
            } else {
              log('ブロックに失敗: 指定のブロッカーが見つからない');
            }
          } else {
            // no blocker -> hit player: break a shield if exists
            if(defender.shield.length > 0){
              const broken = defender.shield.pop();
              // reveal & add to defender's hand (simplified rule)
              defender.hand.push(broken);
              log(`${p} の攻撃がシールドにヒット！ 相手のシールドが破壊され、破壊カード ${broken.name} は相手の手札へ`);
              // shieldTrigger: if broken card has shieldTrigger ability (we define as ability starting with 'shieldTrigger-') -> resolve effect
              const triggers = broken.abilities ? broken.abilities.filter(a=>a.startsWith('shieldTrigger')) : [];
              triggers.forEach(tr=>{
                if(tr === 'shieldTrigger-draw2'){
                  defender.hand.push(defender.deck.length? defender.deck.pop(): null);
                  defender.hand.push(defender.deck.length? defender.deck.pop(): null);
                  log('シールドトリガー: 2枚ドロー');
                }
              });
              // check winner: if shield now zero and direct attack on player occurs next time -> losing condition handled elsewhere.
            } else {
              // no shields -> direct damage = loss
              log(`${p} が直接ダイレクトアタック！ 勝利！`);
              alert(`${p} の勝利！`);
            }
          }
        } else {
          // attack a creature (opponent creature uid)
          const targetUid = action.target;
          const target = defender.battle.find(c=>c.uid===targetUid);
          if(!target){ log('attack: 対象クリーチャーが見つかりません'); return; }
          log(`${attacker.name} が ${target.name} に攻撃`);
          resolveCombat(attacker, target, p, other(p));
          cleanupDead();
        }
      }
      break;

    case 'end-turn':
      {
        if(state.turn !== action.player){ log('end-turn: ターン不一致'); return; }
        // untap? In DM, creatures do not untap automatically; only at start of your turn creatures become untapped? We'll untap at start of owner's next turn.
        // clear summonedThisTurn flags for their creatures at start of their next turn; here we move turn and do upkeep
        state.turn = other(state.turn);
        // start of new turn: untap all creatures of new player, draw
        const pl = state.players[state.turn];
        pl.battle.forEach(c=>c.tapped = false);
        pl.battle.forEach(c=>c.summonedThisTurn = false);
        // auto draw at start of turn
        if(pl.deck.length) pl.hand.push(pl.deck.pop());
        log('ターン交代 -> ' + state.turn + ' のターン（自動ドロー）');
      }
      break;

    case 'sync-state':
      state = action.state;
      log('full sync 適用');
      break;
  }

  // after applying, if local then broadcast
  if(local){
    send({ type:'action', action });
  }
  renderAll();
}

// helpers
function findAndRemoveFromBattle(owner, uid, remove=true){
  const idx = owner.battle.findIndex(c=>c.uid===uid);
  if(idx===-1) return null;
  return owner.battle[idx];
}

function resolveCombat(aCard, dCard, attackerPlayer, defenderPlayer){
  // simple power comparison: if a.power >= d.power -> defender dies; if d.power >= a.power -> attacker dies; both can die
  const aPow = aCard.power || 0;
  const dPow = dCard.power || 0;
  if(aPow >= dPow){
    // defender dies
    moveToGrave(defenderPlayer, dCard.uid);
    log(`${dCard.name} は破壊された`);
  }
  if(dPow >= aPow){
    moveToGrave(attackerPlayer, aCard.uid);
    log(`${aCard.name} は破壊された`);
  }
}

function moveToGrave(player, uid){
  const pl = state.players[player];
  const idx = pl.battle.findIndex(c=>c.uid===uid);
  if(idx !== -1){
    const card = pl.battle.splice(idx,1)[0];
    pl.grave.push(card);
  } else {
    // could be other zones
  }
}

function cleanupDead(){
  // placeholder: already moved to grave by resolveCombat
}

function resolveSpell(player, card, action){
  const pl = state.players[player];
  const op = state.players[other(player)];
  if(card.id === 's1'){ // draw2
    for(let i=0;i<2;i++) if(pl.deck.length) pl.hand.push(pl.deck.pop());
    log(`${player} が ドロー2 を解決`);
  } else if(card.id === 's2'){ // destroy target creature chosen from op
    if(action.targetUid){
      moveToGrave(other(player), action.targetUid);
      log(`${player} が 呪文で相手クリーチャーを破壊: ${action.targetUid}`);
    } else {
      log('破壊呪文のターゲットが指定されていません');
    }
  } else if(card.id === 's3'){
    // buff: choose your creature uid and give +2000 power temporarily (not implemented fully)
    if(action.targetUid){
      const c = pl.battle.find(x=>x.uid===action.targetUid);
      if(c){ c.power += 2000; log(`${player} の ${c.name} に +2000 （暫定）`); }
    }
  }
}

// -------------------- UI and event binding --------------------
function renderAll(){
  // my side determined by state.localRole
  if(!state.localRole) return;
  const me = state.players[state.localRole];
  const opp = state.players[ other(state.localRole) ];

  document.getElementById('myDeckCount').textContent = me.deck.length;
  document.getElementById('myShieldCount').textContent = me.shield.length;
  document.getElementById('myManaCount').textContent = me.mana.length;
  document.getElementById('myBattleCount').textContent = me.battle.length;

  document.getElementById('opDeckCount').textContent = opp.deck.length;
  document.getElementById('opShieldCount').textContent = opp.shield.length;
  document.getElementById('opManaCount').textContent = opp.mana.length;
  document.getElementById('opBattleCount').textContent = opp.battle.length;

  // my hand
  const myHandDiv = document.getElementById('myHand'); myHandDiv.innerHTML = '';
  me.hand.forEach(c=>{
    const el = document.createElement('div');
    el.className = 'card';
    el.textContent = `${c.name} (c${c.cost}) ${c.type==='creature'? 'p'+c.power : 'S'}`;
    el.onclick = ()=> onClickHandCard(c.uid);
    myHandDiv.appendChild(el);
  });

  // my mana zone
  const myManaDiv = document.getElementById('myManaZone'); myManaDiv.innerHTML = '';
  me.mana.forEach(c=>{
    const el = document.createElement('div'); el.className='card small'; el.textContent = `M:${c.name}`;
    myManaDiv.appendChild(el);
  });

  // battle zones
  const myBattleDiv = document.getElementById('myBattle'); myBattleDiv.innerHTML = '';
  me.battle.forEach(c=>{
    const el = document.createElement('div'); el.className='card small';
    el.textContent = `${c.name}\nP:${c.power}${c.tapped? ' (T)': ''}${c.abilities && c.abilities.length? ' ' + c.abilities.join(','):''}`;
    el.onclick = ()=> onClickBattleCard(c.uid);
    myBattleDiv.appendChild(el);
  });

  const opBattleDiv = document.getElementById('opBattle'); opBattleDiv.innerHTML = '';
  opp.battle.forEach(c=>{
    const el = document.createElement('div'); el.className='card small';
    el.textContent = `${c.name}\nP:${c.power}${c.tapped? ' (T)': ''}${c.abilities && c.abilities.length? ' ' + c.abilities.join(','):''}`;
    opBattleDiv.appendChild(el);
  });

  // opponent visible (we only show some info like last played)
  const opVis = document.getElementById('opVisible'); opVis.innerHTML = '';
  // nothing to show for privacy except maybe broken shields count handled above

  // other UI updates
}

function onClickHandCard(uid){
  const p = state.localRole;
  const me = state.players[p];
  const card = me.hand.find(c=>c.uid===uid);
  if(!card) return;
  // present simple choices: place mana or play
  const choice = confirm('マナに置きますか？OK=マナに置く / キャンセル=召喚/呪文をプレイ');
  if(choice){
    // place to mana
    applyAction({ act:'place-mana', player:p, uid }, true);
  } else {
    // try to play via cost dialog
    const cost = card.cost || 0;
    if(me.mana.length < cost){
      alert('マナが足りません');
      return;
    }
    // for spells that require target, ask for target UID if applicable
    let targetUid = null;
    if(card.type === 'spell' && card.id === 's2'){
      // target enemy creature: choose first one for simplicity if any
      const opp = state.players[ other(p) ];
      if(opp.battle.length === 0){ alert('相手にクリーチャーがいません'); return; }
      // choose the first as target (can be improved with UI)
      targetUid = opp.battle[0].uid;
    } else if(card.type === 'spell' && card.id === 's3'){
      const myb = me.battle;
      if(myb.length === 0){ alert('自分のクリーチャーがいません'); return; }
      targetUid = myb[0].uid;
    }

    const action = { act:'play-card', player:p, uid, cost, targetUid };
    applyAction(action, true);
  }
}

function onClickBattleCard(uid){
  // if it's my card, I can choose to attack (if it's my turn)
  if(state.turn === state.localRole){
    const me = state.players[state.localRole];
    const c = me.battle.find(x=>x.uid===uid);
    if(!c) return;
    // attack options: attack player or attack enemy creature
    const toPlayer = confirm('このクリーチャーで相手プレイヤーを攻撃しますか？OK=プレイヤー / キャンセル=相手クリーチャーを狙う');
    if(toPlayer){
      // check for opponent blockers - defender will be asked to declare block via incoming message; for simplicity attacker may include block decision? We'll allow defender to respond by sending a declare-block action.
      const action = { act:'attack', player: state.localRole, attackerUid: uid, target:'player' };
      applyAction(action, true);
    } else {
      // pick first enemy creature as target (improvable)
      const opp = state.players[ other(state.localRole) ];
      if(opp.battle.length === 0){ alert('相手にクリーチャーがいません'); return; }
      const targetUid = opp.battle[0].uid;
      const action = { act:'attack', player: state.localRole, attackerUid: uid, target: targetUid };
      applyAction(action, true);
    }
  } else {
    alert('自分のターンでしか攻撃できません');
  }
}

// UI binding for global buttons
document.getElementById('placeManaBtn').onclick = ()=>{
  // auto place first hand card to mana for convenience
  const me = state.players[state.localRole];
  if(!me || me.hand.length===0) return alert('手札がありません');
  const c = me.hand[0];
  applyAction({ act:'place-mana', player: state.localRole, uid: c.uid }, true);
};

document.getElementById('endMainBtn').onclick = ()=>{
  // move to battle phase
  state.phase = 'battle';
  log('メインフェイズ終了 -> バトルフェイズ');
  // no server broadcast needed (local change)
  send({ type:'sync', state: serializeStateForSend(state) });
};

document.getElementById('endTurnBtn').onclick = ()=>{
  applyAction({ act:'end-turn', player: state.localRole }, true);
};

document.getElementById('autoDrawBtn').onclick = ()=>{
  applyAction({ act:'draw', player: state.localRole }, true);
};

startBtn.onclick = () => {
  if(!conn || !conn.open) {
    alert('まず相手と接続してください');
    return;
  }
  // determine roles: the peer who initiated connection (the one with lower lexical id?) — simpler: Ask user who is host.
  const asHost = confirm('この端末でゲームの初期状態を作りますか？（OK=ホスト=A / キャンセル=参加者=B）');
  if(asHost){
    state.localRole = 'A';
    startGameAs('A');
  } else {
    state.localRole = 'B';
    // Wait for A to send full-state. But to be robust, ask A to press start as well.
    send({ type:'meta', msg: 'ready-to-receive' });
    log('参加者: ホストが初期状態を送るのを待ちます');
  }
  renderAll();
};

resetBtn.onclick = ()=>{
  state = {
    players: { A:{id:null,deck:[],hand:[],mana:[],battle:[],shield:[],grave:[]}, B:{id:null,deck:[],hand:[],mana:[],battle:[],shield:[],grave:[]} },
    turn:null, phase:'idle', started:false, localRole:null
  };
  send({ type:'sync', state: serializeStateForSend(state) });
  renderAll();
  log('ローカルリセット実行');
};

// When A sent full-state initially, we expect B to receive it in handleMessage => full-state path.
// To ensure A sends the full-state to the correct recipient, modify startGameAs to send full-state once conn is open.
// We already send in startGameAs for A.

renderAll();

</script>
</body>
</html>
