<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>P2P カード対戦（サンプル）</title>
<style>
  body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; background:#0b1220;color:#eef2ff;display:flex;flex-direction:column;align-items:center;padding:18px;}
  .board{display:flex;gap:12px;max-width:1100px;width:100%;}
  .panel{background:#0f1630;padding:12px;border-radius:12px;border:1px solid #223;flex:1;box-shadow:0 6px 18px rgba(0,0,0,.5);}
  h1{margin:6px 0 12px;font-size:18px}
  .controls textarea{width:100%;height:80px;background:#07102a;color:#cfe;text-align:left;padding:8px;border-radius:8px;border:1px solid #233;}
  button{padding:8px 10px;border-radius:8px;border:0;background:#1b2a6b;color:#fff;cursor:pointer;margin:4px 0;}
  .row{display:flex;gap:8px;align-items:center;}
  .card{background:#eaf0ff;color:#0b1430;padding:8px;border-radius:8px;min-width:72px;text-align:center;font-weight:700;}
  .hand{display:flex;gap:8px;flex-wrap:wrap;}
  .log{height:160px;overflow:auto;background:#06102a;padding:8px;border-radius:8px;color:#bfe;}
  .small{font-size:13px;color:#9fb;}
  .status{font-weight:700;}
  .center{display:flex;flex-direction:column;align-items:center;gap:8px;}
</style>
</head>
<body>
  <h1>P2P カード対戦（サンプル） — コピー＆ペーストで接続</h1>
  <div class="board">
    <div class="panel" style="flex:0.9">
      <div class="row">
        <div style="flex:1">
          <div class="small">あなたの名前</div>
          <input id="name" value="Player" style="width:100%;padding:8px;border-radius:8px;border:1px solid #233;background:#07102a;color:#cfe"/>
        </div>
        <div style="width:160px">
          <div class="small">接続状態</div>
          <div id="conn" class="status">未接続</div>
        </div>
      </div>

      <hr/>
      <div class="row" style="gap:12px;">
        <div style="flex:1" class="controls">
          <div class="small">役割: ホスト（作成） / ジョイン（参加）</div>
          <div class="row">
            <button id="makeOffer">① ホスト: Offer 作成</button>
            <button id="acceptOffer">② ジョイン: Offer を受け取って Answer 作成</button>
            <button id="pasteAnswer">③ ホスト: 相手の Answer を貼る</button>
          </div>
          <div class="small">Offer / Answer（コピーして相手に渡す）</div>
          <textarea id="sdpBox" placeholder="ここにOfferまたはAnswerを貼る/取り出す"></textarea>
          <div class="small">接続が確立すると「接続状態」が変わります。Offer/Answerは長いテキストを丸ごとコピーしてください。</div>
        </div>
        <div style="width:300px" class="center panel">
          <div class="small">ゲームログ</div>
          <div id="log" class="log"></div>
          <div style="width:100%;margin-top:8px" class="row">
            <button id="newGame">ゲーム開始（両者が接続後）</button>
            <button id="reset">ローカルリセット</button>
          </div>
        </div>
      </div>

      <hr/>
      <div class="row">
        <div style="flex:1">
          <div class="small">あなた (自分)</div>
          <div class="row">
            <div class="card">HP <span id="myHp">20</span></div>
            <div class="card">Deck <span id="myDeck">10</span></div>
            <div class="card">Hand <span id="myHandCount">0</span></div>
          </div>
          <div class="small">手札</div>
          <div id="myHand" class="hand"></div>
        </div>

        <div style="flex:1">
          <div class="small">相手 (リモート)</div>
          <div class="row">
            <div class="card">HP <span id="opHp">20</span></div>
            <div class="card">Deck <span id="opDeck">10</span></div>
            <div class="card">Hand <span id="opHandCount">0</span></div>
          </div>
          <div class="small">相手の公開手札（相手が明示したカードのみ表示）</div>
          <div id="opVisible" class="hand"></div>
        </div>
      </div>

      <hr/>
      <div class="row">
        <div style="flex:1">
          <div class="small">現在のターン: <span id="turnInfo">—</span></div>
          <div class="small">操作</div>
          <div class="row">
            <button id="endTurn">ターン終了</button>
            <button id="drawCard">ドロー（デバッグ）</button>
            <button id="giveUp">ギブアップ</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  シンプル設計のP2Pゲーム (DataChannel)
  - 手動シグナリング (SDPコピー&ペースト)
  - メッセージはJSONで同期
  - 最初に "new-game" を送って同じ初期状態で開始
  - 以降 "action" メッセージで手番操作を伝播
*/

// ---------- WebRTC P2P シグナリング（手動） ----------
let pc = null;
let dc = null;
let isOfferer = false;
const logEl = document.getElementById('log');
const sdpBox = document.getElementById('sdpBox');
const connEl = document.getElementById('conn');

function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
}
function setStatus(s){ connEl.textContent = s; }

const cfg = { iceServers: [{ urls:'stun:stun.l.google.com:19302' }] };

function ensurePeer(){
  if(pc) return pc;
  pc = new RTCPeerConnection(cfg);
  pc.onicecandidate = (e)=> {
    if(e.candidate === null) {
      // 最終SDPができた
      sdpBox.value = pc.localDescription.sdp;
    }
  };
  pc.ondatachannel = (ev)=> {
    dc = ev.channel;
    setupDataChannel(dc);
  };
  pc.onconnectionstatechange = ()=> {
    setStatus(pc.connectionState);
    log('PC state: ' + pc.connectionState);
  };
  return pc;
}

function setupDataChannel(channel){
  dc = channel;
  dc.onopen = ()=> { log('DataChannel open'); setStatus('接続済み'); };
  dc.onclose = ()=> { log('DataChannel closed'); setStatus('切断'); };
  dc.onmessage = (ev)=> {
    handleMessage(ev.data);
  };
}

// ① ホスト: Offer作成（OffererがDataChannelを作る）
document.getElementById('makeOffer').onclick = async ()=>{
  isOfferer = true;
  const pc = ensurePeer();
  dc = pc.createDataChannel('game');
  setupDataChannel(dc);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // localDescription.sdp はICE収集終了で書き変わるが、簡易版としてここを表示
  sdpBox.value = btoa(JSON.stringify({type:pc.localDescription.type, sdp:pc.localDescription.sdp}));
  log('Offer 生成 -> コピーして相手に送ってください（base64 JSON）');
};

// ② ジョイン: Offerを貼ってAnswerを作成
document.getElementById('acceptOffer').onclick = async ()=>{
  try {
    const raw = sdpBox.value.trim();
    if(!raw) { alert('Offerを貼ってください'); return; }
    const parsed = JSON.parse(atob(raw));
    const pc = ensurePeer();
    await pc.setRemoteDescription(parsed);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    // 返すAnswerをコピーしてホストに渡す
    sdpBox.value = btoa(JSON.stringify({type:pc.localDescription.type, sdp:pc.localDescription.sdp}));
    log('Answer を生成しました -> ホストに貼ってもらってください（base64 JSON）');
  } catch(e){ console.error(e); alert('処理失敗: ' + e.message); }
};

// ③ ホスト: 相手の Answer を貼る（最後の手順）
document.getElementById('pasteAnswer').onclick = async ()=>{
  try {
    const raw = sdpBox.value.trim();
    if(!raw) { alert('Answerを貼ってください'); return; }
    const parsed = JSON.parse(atob(raw));
    const pc = ensurePeer();
    await pc.setRemoteDescription(parsed);
    log('Answerを設定しました。接続を待ってください。');
  } catch(e){ console.error(e); alert('処理失敗: ' + e.message); }
};

// ---------- ゲームロジック（Stateはシンプルで双方で同じ状態を持つ） ----------
let state = null; // game state
let myId = null; // "A" or "B" — ホストがA（offerer）
function buildEmptyState(){
  return {
    players: {
      A: { name: null, hp:20, deck:[], hand:[] , visible:[] },
      B: { name: null, hp:20, deck:[], hand:[] , visible:[] }
    },
    turn: 'A', // A or B
    started: false,
    winner: null,
  };
}

function rngDeck(){
  // 単純な攻撃カード（1..6）と少し特殊（heal2, shield）
  const arr = [];
  for(let i=0;i<8;i++) arr.push({type:'atk',v: rint(1,6)});
  arr.push({type:'atk',v:2}); arr.push({type:'atk',v:3});
  // シャッフル
  for(let i=arr.length-1;i>0;i--){ const j=rint(0,i); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}

// UI 更新
function refreshUI(){
  document.getElementById('myHp').textContent = state.players[myId].hp;
  document.getElementById('opHp').textContent = state.players[otherId()].hp;
  document.getElementById('myDeck').textContent = state.players[myId].deck.length;
  document.getElementById('opDeck').textContent = state.players[otherId()].deck.length;
  document.getElementById('myHandCount').textContent = state.players[myId].hand.length;
  document.getElementById('opHandCount').textContent = state.players[otherId()].hand.length;
  document.getElementById('turnInfo').textContent = (state.turn===myId)? 'あなたのターン' : '相手のターン';
  // 手札表示（非公開） -> we show cards as clickable for player
  const myHandDiv = document.getElementById('myHand'); myHandDiv.innerHTML='';
  state.players[myId].hand.forEach((card,idx)=>{
    const btn = document.createElement('button');
    btn.className='card';
    btn.textContent = card.type==='atk' ? 'ATK ' + card.v : card.type.toUpperCase();
    btn.onclick = ()=> tryPlayCard(idx);
    myHandDiv.appendChild(btn);
  });
  // 相手の公開カード（visible）
  const opDiv = document.getElementById('opVisible'); opDiv.innerHTML='';
  state.players[otherId()].visible.forEach((c)=> {
    const el = document.createElement('div'); el.className='card'; el.textContent = c.type==='atk' ? 'ATK ' + c.v : c.type.toUpperCase();
    opDiv.appendChild(el);
  });
}

// helper
function otherId(){ return myId==='A' ? 'B':'A'; }

// send JSON over DataChannel (and also locally apply for host if needed)
function sendMessage(obj){
  const text = JSON.stringify(obj);
  if(dc && dc.readyState==='open'){
    dc.send(text);
  } else {
    log('Warning: DataChannel not open, cannot send');
  }
}

// handle incoming messages
function handleMessage(raw){
  try {
    const obj = JSON.parse(raw);
    if(obj.type==='meta'){
      log('META: '+obj.msg);
    } else if(obj.type==='game-state'){
      // full state replace (used at start)
      state = obj.state;
      refreshUI();
      log('ゲーム状態を受信（全体同期）');
    } else if(obj.type==='action'){
      applyAction(obj.action, false); // false means remote action
    }
  } catch(e){ console.error(e); }
}

// applyAction applies one atomic action and (if local) broadcasts it
function applyAction(action, local=true){
  // action: {act:'play'|'end'|'draw'|'new-game'|'giveup', player: 'A'|'B', payload: {...}}
  const p = action.player;
  if(action.act==='new-game'){
    state = buildEmptyState();
    state.players.A.name = action.payload.names.A;
    state.players.B.name = action.payload.names.B;
    state.players.A.deck = rngDeck();
    state.players.B.deck = rngDeck();
    // initial draw 3
    for(let i=0;i<3;i++){
      drawFor('A'); drawFor('B');
    }
    state.started = true;
    state.turn = 'A';
    refreshUI();
    log('新規ゲーム開始');
  } else if(action.act==='play'){
    if(state.turn !== action.player){ log('それは今できない操作'); return; }
    const cardIndex = action.payload.idx;
    const card = state.players[p].hand.splice(cardIndex,1)[0];
    // 効果を適用 (ここは簡単: ATK => 相手にダメージ)
    if(card.type==='atk'){
      state.players[otherOf(p)].hp -= card.v;
      if(state.players[otherOf(p)].hp < 0) state.players[otherOf(p)].hp = 0;
      // 相手のvisibleに追加（相手に見える公開カード）
      state.players[otherOf(p)].visible.push({type:card.type,v:card.v});
      log(`${p} が ATK ${card.v} をプレイ -> ${otherOf(p)} に ${card.v} ダメージ`);
    }
    // 勝利判定
    if(state.players[otherOf(p)].hp <= 0){
      state.winner = p;
      log(`勝者: ${p}`);
    }
    // local/UI更新
    refreshUI();
  } else if(action.act==='end'){
    // ターン交代
    state.turn = otherOf(state.turn);
    // ターン開始時ドロー
    drawFor(state.turn);
    refreshUI();
    log('ターン終了 -> ' + state.turn + ' のターン');
  } else if(action.act==='draw'){
    drawFor(p);
    refreshUI();
    log(`${p} がドロー`);
  } else if(action.act==='giveup'){
    state.winner = otherOf(action.player);
    log(action.player + ' がギブアップ。勝者: ' + state.winner);
  }
  // broadcast if local action
  if(local){
    sendMessage({type:'action', action});
  }
}

function otherOf(x){ return x==='A'?'B':'A'; }

function drawFor(pid){
  const pl = state.players[pid];
  if(pl.deck.length === 0) return;
  const card = pl.deck.shift();
  if(pl.hand.length < 5) pl.hand.push(card); // 手札上限
  // don't automatically reveal to opponent
}

// UI actions
async function tryPlayCard(idx){
  if(!state || !state.started) return alert('ゲームが始まっていません');
  if(state.turn !== myId) return alert('自分のターンではありません');
  // build action and apply locally (will be sent)
  const action = { act:'play', player: myId, payload:{ idx } };
  applyAction(action, true);
}

// buttons
document.getElementById('newGame').onclick = ()=>{
  if(!dc || dc.readyState!=='open') { alert('まず相手と接続してください'); return; }
  // determine roles: offerer is A
  myId = isOfferer ? 'A' : 'B';
  const names = { A: document.getElementById('name').value || 'A', B: 'Remote' };
  if(myId==='B'){ names.B = document.getElementById('name').value || 'B'; names.A = 'Remote'; }
  // send new-game
  const payload = { names };
  const action = { act:'new-game', player: myId, payload };
  applyAction({ act:'new-game', player: myId, payload }, true);
  // Also broadcast state as full sync (conservative)
  sendMessage({type:'game-state', state});
};

document.getElementById('endTurn').onclick = ()=>{
  if(!state || !state.started) return;
  if(state.turn !== myId) return alert('自分のターンではありません');
  const action = { act:'end', player: myId, payload:{} };
  applyAction(action, true);
};

document.getElementById('drawCard').onclick = ()=>{
  const action = { act:'draw', player: myId, payload:{} };
  applyAction(action, true);
};

document.getElementById('giveUp').onclick = ()=>{
  if(!confirm('本当にギブアップしますか？')) return;
  const action = { act:'giveup', player: myId, payload:{} };
  applyAction(action, true);
};

document.getElementById('reset').onclick = ()=>{
  state = buildEmptyState();
  myId = null; isOfferer = false;
  if(dc){ try{ dc.close(); }catch{} }
  if(pc){ try{ pc.close(); }catch{} }
  pc=dc=null;
  sdpBox.value='';
  setStatus('未接続');
  log('ローカルリセット');
  refreshUI();
};

// 初期
state = buildEmptyState();
refreshUI();

</script>
</body>
</html>
